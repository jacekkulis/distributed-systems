// **********************************************************************
//
// Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.3
//
// <auto-generated>
//
// Generated from file `Chat.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Chat_h__
#define __Chat_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Proxy.h>
#include <Ice/GCObject.h>
#include <Ice/AsyncResult.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <Ice/StreamF.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 306
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 3
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace Chat
{

class GroupServer;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Chat::GroupServer>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Chat::GroupServer*);

class GroupServerManager;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Chat::GroupServerManager>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Chat::GroupServerManager*);

class User;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Chat::User>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Chat::User*);

class ChatServer;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Chat::ChatServer>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Chat::ChatServer*);

}

}

namespace Chat
{

class GroupServer;
::Ice::Object* upCast(::Chat::GroupServer*);
typedef ::IceInternal::Handle< ::Chat::GroupServer> GroupServerPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Chat::GroupServer> GroupServerPrx;
void __patch(GroupServerPtr&, const ::Ice::ObjectPtr&);

class GroupServerManager;
::Ice::Object* upCast(::Chat::GroupServerManager*);
typedef ::IceInternal::Handle< ::Chat::GroupServerManager> GroupServerManagerPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Chat::GroupServerManager> GroupServerManagerPrx;
void __patch(GroupServerManagerPtr&, const ::Ice::ObjectPtr&);

class User;
::Ice::Object* upCast(::Chat::User*);
typedef ::IceInternal::Handle< ::Chat::User> UserPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Chat::User> UserPrx;
void __patch(UserPtr&, const ::Ice::ObjectPtr&);

class ChatServer;
::Ice::Object* upCast(::Chat::ChatServer*);
typedef ::IceInternal::Handle< ::Chat::ChatServer> ChatServerPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Chat::ChatServer> ChatServerPrx;
void __patch(ChatServerPtr&, const ::Ice::ObjectPtr&);

}

namespace Chat
{

class NameDoesNotExist : public ::Ice::UserException
{
public:

    NameDoesNotExist() {}
    virtual ~NameDoesNotExist() throw();

    virtual ::std::string ice_name() const;
    virtual NameDoesNotExist* ice_clone() const;
    virtual void ice_throw() const;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
};

static NameDoesNotExist __NameDoesNotExist_init;

class NameAlreadyExists : public ::Ice::UserException
{
public:

    NameAlreadyExists() {}
    virtual ~NameAlreadyExists() throw();

    virtual ::std::string ice_name() const;
    virtual NameAlreadyExists* ice_clone() const;
    virtual void ice_throw() const;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
};

class ServerAlreadyRegistered : public ::Ice::UserException
{
public:

    ServerAlreadyRegistered() {}
    virtual ~ServerAlreadyRegistered() throw();

    virtual ::std::string ice_name() const;
    virtual ServerAlreadyRegistered* ice_clone() const;
    virtual void ice_throw() const;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
};

class ServerDoesNotExist : public ::Ice::UserException
{
public:

    ServerDoesNotExist() {}
    virtual ~ServerDoesNotExist() throw();

    virtual ::std::string ice_name() const;
    virtual ServerDoesNotExist* ice_clone() const;
    virtual void ice_throw() const;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
};

class UserAlreadyRegistered : public ::Ice::UserException
{
public:

    UserAlreadyRegistered() {}
    virtual ~UserAlreadyRegistered() throw();

    virtual ::std::string ice_name() const;
    virtual UserAlreadyRegistered* ice_clone() const;
    virtual void ice_throw() const;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
};

class UserDoesNotExist : public ::Ice::UserException
{
public:

    UserDoesNotExist() {}
    virtual ~UserDoesNotExist() throw();

    virtual ::std::string ice_name() const;
    virtual UserDoesNotExist* ice_clone() const;
    virtual void ice_throw() const;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
};

typedef ::std::vector< ::Chat::GroupServerPrx> Groups;

typedef ::std::vector< ::Chat::UserPrx> Users;

}

namespace Ice
{
template<>
struct StreamableTraits< ::Chat::NameDoesNotExist>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Chat::NameAlreadyExists>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Chat::ServerAlreadyRegistered>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Chat::ServerDoesNotExist>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Chat::UserAlreadyRegistered>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Chat::UserDoesNotExist>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

}

namespace Chat
{

class Callback_ChatServer_LogIn_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_LogIn_Base> Callback_ChatServer_LogInPtr;

class Callback_ChatServer_GetUserByName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_GetUserByName_Base> Callback_ChatServer_GetUserByNamePtr;

class Callback_ChatServer_GroupList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_GroupList_Base> Callback_ChatServer_GroupListPtr;

class Callback_ChatServer_GetGroupServerByName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_GetGroupServerByName_Base> Callback_ChatServer_GetGroupServerByNamePtr;

class Callback_ChatServer_CreateGroup_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_CreateGroup_Base> Callback_ChatServer_CreateGroupPtr;

class Callback_ChatServer_DeleteGroup_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_DeleteGroup_Base> Callback_ChatServer_DeleteGroupPtr;

class Callback_ChatServer_RegisterServer_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_RegisterServer_Base> Callback_ChatServer_RegisterServerPtr;

class Callback_ChatServer_UnregisterServer_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_UnregisterServer_Base> Callback_ChatServer_UnregisterServerPtr;

class Callback_GroupServer_Name_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GroupServer_Name_Base> Callback_GroupServer_NamePtr;

class Callback_GroupServer_Join_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GroupServer_Join_Base> Callback_GroupServer_JoinPtr;

class Callback_GroupServer_Leave_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GroupServer_Leave_Base> Callback_GroupServer_LeavePtr;

class Callback_GroupServer_SendMessage_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GroupServer_SendMessage_Base> Callback_GroupServer_SendMessagePtr;

class Callback_GroupServer_UserList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GroupServer_UserList_Base> Callback_GroupServer_UserListPtr;

class Callback_GroupServerManager_CreateGroup_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GroupServerManager_CreateGroup_Base> Callback_GroupServerManager_CreateGroupPtr;

class Callback_GroupServerManager_ListGroups_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GroupServerManager_ListGroups_Base> Callback_GroupServerManager_ListGroupsPtr;

class Callback_GroupServerManager_DeleteGroup_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GroupServerManager_DeleteGroup_Base> Callback_GroupServerManager_DeleteGroupPtr;

class Callback_GroupServerManager_GetGroupServerByName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GroupServerManager_GetGroupServerByName_Base> Callback_GroupServerManager_GetGroupServerByNamePtr;

class Callback_User_GetName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_User_GetName_Base> Callback_User_GetNamePtr;

class Callback_User_ReceiveText_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_User_ReceiveText_Base> Callback_User_ReceiveTextPtr;

class Callback_User_ReceivePrivateText_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_User_ReceivePrivateText_Base> Callback_User_ReceivePrivateTextPtr;

}

namespace IceProxy
{

namespace Chat
{

class ChatServer : virtual public ::IceProxy::Ice::Object
{
public:

    void LogIn(const ::Chat::UserPrx& __p_callback)
    {
        LogIn(__p_callback, 0);
    }
    void LogIn(const ::Chat::UserPrx& __p_callback, const ::Ice::Context& __ctx)
    {
        LogIn(__p_callback, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_LogIn(const ::Chat::UserPrx& __p_callback, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_LogIn(__p_callback, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_LogIn(const ::Chat::UserPrx& __p_callback, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_LogIn(__p_callback, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_LogIn(const ::Chat::UserPrx& __p_callback, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_LogIn(__p_callback, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_LogIn(const ::Chat::UserPrx& __p_callback, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_LogIn(__p_callback, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_LogIn(const ::Chat::UserPrx& __p_callback, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_LogIn(const ::Chat::UserPrx& __p_callback)
    {
        return begin_LogIn(__p_callback, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_LogIn(const ::Chat::UserPrx& __p_callback, const ::Ice::Context& __ctx)
    {
        return begin_LogIn(__p_callback, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_LogIn(const ::Chat::UserPrx& __p_callback, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_LogIn(__p_callback, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_LogIn(const ::Chat::UserPrx& __p_callback, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_LogIn(__p_callback, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_LogIn(const ::Chat::UserPrx& __p_callback, const ::Chat::Callback_ChatServer_LogInPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_LogIn(__p_callback, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_LogIn(const ::Chat::UserPrx& __p_callback, const ::Ice::Context& __ctx, const ::Chat::Callback_ChatServer_LogInPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_LogIn(__p_callback, &__ctx, __del, __cookie);
    }

    void end_LogIn(const ::Ice::AsyncResultPtr&);
    
private:

    void LogIn(const ::Chat::UserPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_LogIn(const ::Chat::UserPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Chat::UserPrx GetUserByName(const ::std::string& __p_name)
    {
        return GetUserByName(__p_name, 0);
    }
    ::Chat::UserPrx GetUserByName(const ::std::string& __p_name, const ::Ice::Context& __ctx)
    {
        return GetUserByName(__p_name, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_GetUserByName(const ::std::string& __p_name, const ::IceInternal::Function<void (const ::Chat::UserPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_GetUserByName(__p_name, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_GetUserByName(const ::std::string& __p_name, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_GetUserByName(__p_name, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_GetUserByName(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Chat::UserPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_GetUserByName(__p_name, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_GetUserByName(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_GetUserByName(__p_name, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_GetUserByName(const ::std::string& __p_name, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Chat::UserPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_GetUserByName(const ::std::string& __p_name)
    {
        return begin_GetUserByName(__p_name, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetUserByName(const ::std::string& __p_name, const ::Ice::Context& __ctx)
    {
        return begin_GetUserByName(__p_name, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetUserByName(const ::std::string& __p_name, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetUserByName(__p_name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetUserByName(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetUserByName(__p_name, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetUserByName(const ::std::string& __p_name, const ::Chat::Callback_ChatServer_GetUserByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetUserByName(__p_name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetUserByName(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::Chat::Callback_ChatServer_GetUserByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetUserByName(__p_name, &__ctx, __del, __cookie);
    }

    ::Chat::UserPrx end_GetUserByName(const ::Ice::AsyncResultPtr&);
    
private:

    ::Chat::UserPrx GetUserByName(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_GetUserByName(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Chat::Groups GroupList()
    {
        return GroupList(0);
    }
    ::Chat::Groups GroupList(const ::Ice::Context& __ctx)
    {
        return GroupList(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_GroupList(const ::IceInternal::Function<void (const ::Chat::Groups&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_GroupList(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_GroupList(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_GroupList(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_GroupList(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Chat::Groups&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_GroupList(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_GroupList(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_GroupList(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_GroupList(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Chat::Groups&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_GroupList()
    {
        return begin_GroupList(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GroupList(const ::Ice::Context& __ctx)
    {
        return begin_GroupList(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GroupList(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GroupList(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GroupList(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GroupList(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GroupList(const ::Chat::Callback_ChatServer_GroupListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GroupList(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GroupList(const ::Ice::Context& __ctx, const ::Chat::Callback_ChatServer_GroupListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GroupList(&__ctx, __del, __cookie);
    }

    ::Chat::Groups end_GroupList(const ::Ice::AsyncResultPtr&);
    
private:

    ::Chat::Groups GroupList(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_GroupList(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Chat::GroupServerPrx GetGroupServerByName(const ::std::string& __p_name)
    {
        return GetGroupServerByName(__p_name, 0);
    }
    ::Chat::GroupServerPrx GetGroupServerByName(const ::std::string& __p_name, const ::Ice::Context& __ctx)
    {
        return GetGroupServerByName(__p_name, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_GetGroupServerByName(const ::std::string& __p_name, const ::IceInternal::Function<void (const ::Chat::GroupServerPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_GetGroupServerByName(__p_name, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_GetGroupServerByName(const ::std::string& __p_name, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_GetGroupServerByName(__p_name, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_GetGroupServerByName(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Chat::GroupServerPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_GetGroupServerByName(__p_name, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_GetGroupServerByName(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_GetGroupServerByName(__p_name, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_GetGroupServerByName(const ::std::string& __p_name, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Chat::GroupServerPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_GetGroupServerByName(const ::std::string& __p_name)
    {
        return begin_GetGroupServerByName(__p_name, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetGroupServerByName(const ::std::string& __p_name, const ::Ice::Context& __ctx)
    {
        return begin_GetGroupServerByName(__p_name, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetGroupServerByName(const ::std::string& __p_name, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetGroupServerByName(__p_name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetGroupServerByName(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetGroupServerByName(__p_name, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetGroupServerByName(const ::std::string& __p_name, const ::Chat::Callback_ChatServer_GetGroupServerByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetGroupServerByName(__p_name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetGroupServerByName(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::Chat::Callback_ChatServer_GetGroupServerByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetGroupServerByName(__p_name, &__ctx, __del, __cookie);
    }

    ::Chat::GroupServerPrx end_GetGroupServerByName(const ::Ice::AsyncResultPtr&);
    
private:

    ::Chat::GroupServerPrx GetGroupServerByName(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_GetGroupServerByName(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void CreateGroup(const ::std::string& __p_name)
    {
        CreateGroup(__p_name, 0);
    }
    void CreateGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx)
    {
        CreateGroup(__p_name, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_CreateGroup(const ::std::string& __p_name, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_CreateGroup(__p_name, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_CreateGroup(const ::std::string& __p_name, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_CreateGroup(__p_name, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_CreateGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_CreateGroup(__p_name, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_CreateGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_CreateGroup(__p_name, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_CreateGroup(const ::std::string& __p_name, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& __p_name)
    {
        return begin_CreateGroup(__p_name, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx)
    {
        return begin_CreateGroup(__p_name, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& __p_name, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_CreateGroup(__p_name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_CreateGroup(__p_name, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& __p_name, const ::Chat::Callback_ChatServer_CreateGroupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_CreateGroup(__p_name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::Chat::Callback_ChatServer_CreateGroupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_CreateGroup(__p_name, &__ctx, __del, __cookie);
    }

    void end_CreateGroup(const ::Ice::AsyncResultPtr&);
    
private:

    void CreateGroup(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void DeleteGroup(const ::std::string& __p_name)
    {
        DeleteGroup(__p_name, 0);
    }
    void DeleteGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx)
    {
        DeleteGroup(__p_name, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_DeleteGroup(const ::std::string& __p_name, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_DeleteGroup(__p_name, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_DeleteGroup(const ::std::string& __p_name, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_DeleteGroup(__p_name, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_DeleteGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_DeleteGroup(__p_name, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_DeleteGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_DeleteGroup(__p_name, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_DeleteGroup(const ::std::string& __p_name, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& __p_name)
    {
        return begin_DeleteGroup(__p_name, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx)
    {
        return begin_DeleteGroup(__p_name, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& __p_name, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_DeleteGroup(__p_name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_DeleteGroup(__p_name, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& __p_name, const ::Chat::Callback_ChatServer_DeleteGroupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_DeleteGroup(__p_name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::Chat::Callback_ChatServer_DeleteGroupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_DeleteGroup(__p_name, &__ctx, __del, __cookie);
    }

    void end_DeleteGroup(const ::Ice::AsyncResultPtr&);
    
private:

    void DeleteGroup(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void RegisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager)
    {
        RegisterServer(__p_serverManager, 0);
    }
    void RegisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::Context& __ctx)
    {
        RegisterServer(__p_serverManager, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_RegisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_RegisterServer(__p_serverManager, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_RegisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_RegisterServer(__p_serverManager, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_RegisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_RegisterServer(__p_serverManager, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_RegisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_RegisterServer(__p_serverManager, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_RegisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_RegisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager)
    {
        return begin_RegisterServer(__p_serverManager, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RegisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::Context& __ctx)
    {
        return begin_RegisterServer(__p_serverManager, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RegisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_RegisterServer(__p_serverManager, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_RegisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_RegisterServer(__p_serverManager, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_RegisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Chat::Callback_ChatServer_RegisterServerPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_RegisterServer(__p_serverManager, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_RegisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::Context& __ctx, const ::Chat::Callback_ChatServer_RegisterServerPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_RegisterServer(__p_serverManager, &__ctx, __del, __cookie);
    }

    void end_RegisterServer(const ::Ice::AsyncResultPtr&);
    
private:

    void RegisterServer(const ::Chat::GroupServerManagerPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_RegisterServer(const ::Chat::GroupServerManagerPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void UnregisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager)
    {
        UnregisterServer(__p_serverManager, 0);
    }
    void UnregisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::Context& __ctx)
    {
        UnregisterServer(__p_serverManager, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_UnregisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_UnregisterServer(__p_serverManager, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_UnregisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_UnregisterServer(__p_serverManager, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_UnregisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_UnregisterServer(__p_serverManager, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_UnregisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_UnregisterServer(__p_serverManager, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_UnregisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_UnregisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager)
    {
        return begin_UnregisterServer(__p_serverManager, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UnregisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::Context& __ctx)
    {
        return begin_UnregisterServer(__p_serverManager, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UnregisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_UnregisterServer(__p_serverManager, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_UnregisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_UnregisterServer(__p_serverManager, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_UnregisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Chat::Callback_ChatServer_UnregisterServerPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_UnregisterServer(__p_serverManager, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_UnregisterServer(const ::Chat::GroupServerManagerPrx& __p_serverManager, const ::Ice::Context& __ctx, const ::Chat::Callback_ChatServer_UnregisterServerPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_UnregisterServer(__p_serverManager, &__ctx, __del, __cookie);
    }

    void end_UnregisterServer(const ::Ice::AsyncResultPtr&);
    
private:

    void UnregisterServer(const ::Chat::GroupServerManagerPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_UnregisterServer(const ::Chat::GroupServerManagerPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<ChatServer> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_secure(bool __secure) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_twoway() const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_oneway() const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_batchOneway() const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_datagram() const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_batchDatagram() const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_compress(bool __compress) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_timeout(int __timeout) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class GroupServer : virtual public ::IceProxy::Ice::Object
{
public:

    ::std::string Name()
    {
        return Name(0);
    }
    ::std::string Name(const ::Ice::Context& __ctx)
    {
        return Name(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_Name(const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_Name(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_Name(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_Name(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_Name(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_Name(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_Name(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_Name(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_Name(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_Name()
    {
        return begin_Name(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_Name(const ::Ice::Context& __ctx)
    {
        return begin_Name(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_Name(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_Name(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_Name(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_Name(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_Name(const ::Chat::Callback_GroupServer_NamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_Name(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_Name(const ::Ice::Context& __ctx, const ::Chat::Callback_GroupServer_NamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_Name(&__ctx, __del, __cookie);
    }

    ::std::string end_Name(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string Name(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_Name(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void Join(const ::Chat::UserPrx& __p_who)
    {
        Join(__p_who, 0);
    }
    void Join(const ::Chat::UserPrx& __p_who, const ::Ice::Context& __ctx)
    {
        Join(__p_who, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_Join(const ::Chat::UserPrx& __p_who, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_Join(__p_who, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_Join(const ::Chat::UserPrx& __p_who, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_Join(__p_who, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_Join(const ::Chat::UserPrx& __p_who, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_Join(__p_who, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_Join(const ::Chat::UserPrx& __p_who, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_Join(__p_who, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_Join(const ::Chat::UserPrx& __p_who, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_Join(const ::Chat::UserPrx& __p_who)
    {
        return begin_Join(__p_who, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_Join(const ::Chat::UserPrx& __p_who, const ::Ice::Context& __ctx)
    {
        return begin_Join(__p_who, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_Join(const ::Chat::UserPrx& __p_who, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_Join(__p_who, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_Join(const ::Chat::UserPrx& __p_who, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_Join(__p_who, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_Join(const ::Chat::UserPrx& __p_who, const ::Chat::Callback_GroupServer_JoinPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_Join(__p_who, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_Join(const ::Chat::UserPrx& __p_who, const ::Ice::Context& __ctx, const ::Chat::Callback_GroupServer_JoinPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_Join(__p_who, &__ctx, __del, __cookie);
    }

    void end_Join(const ::Ice::AsyncResultPtr&);
    
private:

    void Join(const ::Chat::UserPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_Join(const ::Chat::UserPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void Leave(const ::Chat::UserPrx& __p_who)
    {
        Leave(__p_who, 0);
    }
    void Leave(const ::Chat::UserPrx& __p_who, const ::Ice::Context& __ctx)
    {
        Leave(__p_who, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_Leave(const ::Chat::UserPrx& __p_who, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_Leave(__p_who, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_Leave(const ::Chat::UserPrx& __p_who, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_Leave(__p_who, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_Leave(const ::Chat::UserPrx& __p_who, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_Leave(__p_who, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_Leave(const ::Chat::UserPrx& __p_who, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_Leave(__p_who, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_Leave(const ::Chat::UserPrx& __p_who, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_Leave(const ::Chat::UserPrx& __p_who)
    {
        return begin_Leave(__p_who, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_Leave(const ::Chat::UserPrx& __p_who, const ::Ice::Context& __ctx)
    {
        return begin_Leave(__p_who, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_Leave(const ::Chat::UserPrx& __p_who, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_Leave(__p_who, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_Leave(const ::Chat::UserPrx& __p_who, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_Leave(__p_who, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_Leave(const ::Chat::UserPrx& __p_who, const ::Chat::Callback_GroupServer_LeavePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_Leave(__p_who, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_Leave(const ::Chat::UserPrx& __p_who, const ::Ice::Context& __ctx, const ::Chat::Callback_GroupServer_LeavePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_Leave(__p_who, &__ctx, __del, __cookie);
    }

    void end_Leave(const ::Ice::AsyncResultPtr&);
    
private:

    void Leave(const ::Chat::UserPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_Leave(const ::Chat::UserPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void SendMessage(const ::std::string& __p_message, const ::Chat::UserPrx& __p_sender)
    {
        SendMessage(__p_message, __p_sender, 0);
    }
    void SendMessage(const ::std::string& __p_message, const ::Chat::UserPrx& __p_sender, const ::Ice::Context& __ctx)
    {
        SendMessage(__p_message, __p_sender, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_SendMessage(const ::std::string& __p_message, const ::Chat::UserPrx& __p_sender, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_SendMessage(__p_message, __p_sender, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_SendMessage(const ::std::string& __p_message, const ::Chat::UserPrx& __p_sender, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_SendMessage(__p_message, __p_sender, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_SendMessage(const ::std::string& __p_message, const ::Chat::UserPrx& __p_sender, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_SendMessage(__p_message, __p_sender, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_SendMessage(const ::std::string& __p_message, const ::Chat::UserPrx& __p_sender, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_SendMessage(__p_message, __p_sender, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_SendMessage(const ::std::string& __p_message, const ::Chat::UserPrx& __p_sender, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_SendMessage(const ::std::string& __p_message, const ::Chat::UserPrx& __p_sender)
    {
        return begin_SendMessage(__p_message, __p_sender, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SendMessage(const ::std::string& __p_message, const ::Chat::UserPrx& __p_sender, const ::Ice::Context& __ctx)
    {
        return begin_SendMessage(__p_message, __p_sender, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SendMessage(const ::std::string& __p_message, const ::Chat::UserPrx& __p_sender, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SendMessage(__p_message, __p_sender, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SendMessage(const ::std::string& __p_message, const ::Chat::UserPrx& __p_sender, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SendMessage(__p_message, __p_sender, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SendMessage(const ::std::string& __p_message, const ::Chat::UserPrx& __p_sender, const ::Chat::Callback_GroupServer_SendMessagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SendMessage(__p_message, __p_sender, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SendMessage(const ::std::string& __p_message, const ::Chat::UserPrx& __p_sender, const ::Ice::Context& __ctx, const ::Chat::Callback_GroupServer_SendMessagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SendMessage(__p_message, __p_sender, &__ctx, __del, __cookie);
    }

    void end_SendMessage(const ::Ice::AsyncResultPtr&);
    
private:

    void SendMessage(const ::std::string&, const ::Chat::UserPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_SendMessage(const ::std::string&, const ::Chat::UserPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Chat::Users UserList()
    {
        return UserList(0);
    }
    ::Chat::Users UserList(const ::Ice::Context& __ctx)
    {
        return UserList(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_UserList(const ::IceInternal::Function<void (const ::Chat::Users&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_UserList(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_UserList(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_UserList(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_UserList(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Chat::Users&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_UserList(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_UserList(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_UserList(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_UserList(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Chat::Users&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_UserList()
    {
        return begin_UserList(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UserList(const ::Ice::Context& __ctx)
    {
        return begin_UserList(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UserList(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_UserList(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_UserList(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_UserList(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_UserList(const ::Chat::Callback_GroupServer_UserListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_UserList(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_UserList(const ::Ice::Context& __ctx, const ::Chat::Callback_GroupServer_UserListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_UserList(&__ctx, __del, __cookie);
    }

    ::Chat::Users end_UserList(const ::Ice::AsyncResultPtr&);
    
private:

    ::Chat::Users UserList(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_UserList(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<GroupServer> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_secure(bool __secure) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_twoway() const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_oneway() const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_batchOneway() const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_datagram() const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_batchDatagram() const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_compress(bool __compress) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_timeout(int __timeout) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServer> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<GroupServer*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class GroupServerManager : virtual public ::IceProxy::Ice::Object
{
public:

    ::Chat::GroupServerPrx CreateGroup(const ::std::string& __p_name)
    {
        return CreateGroup(__p_name, 0);
    }
    ::Chat::GroupServerPrx CreateGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx)
    {
        return CreateGroup(__p_name, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_CreateGroup(const ::std::string& __p_name, const ::IceInternal::Function<void (const ::Chat::GroupServerPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_CreateGroup(__p_name, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_CreateGroup(const ::std::string& __p_name, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_CreateGroup(__p_name, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_CreateGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Chat::GroupServerPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_CreateGroup(__p_name, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_CreateGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_CreateGroup(__p_name, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_CreateGroup(const ::std::string& __p_name, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Chat::GroupServerPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& __p_name)
    {
        return begin_CreateGroup(__p_name, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx)
    {
        return begin_CreateGroup(__p_name, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& __p_name, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_CreateGroup(__p_name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_CreateGroup(__p_name, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& __p_name, const ::Chat::Callback_GroupServerManager_CreateGroupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_CreateGroup(__p_name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::Chat::Callback_GroupServerManager_CreateGroupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_CreateGroup(__p_name, &__ctx, __del, __cookie);
    }

    ::Chat::GroupServerPrx end_CreateGroup(const ::Ice::AsyncResultPtr&);
    
private:

    ::Chat::GroupServerPrx CreateGroup(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Chat::Groups ListGroups()
    {
        return ListGroups(0);
    }
    ::Chat::Groups ListGroups(const ::Ice::Context& __ctx)
    {
        return ListGroups(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_ListGroups(const ::IceInternal::Function<void (const ::Chat::Groups&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_ListGroups(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_ListGroups(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ListGroups(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_ListGroups(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Chat::Groups&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_ListGroups(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_ListGroups(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ListGroups(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_ListGroups(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Chat::Groups&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_ListGroups()
    {
        return begin_ListGroups(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ListGroups(const ::Ice::Context& __ctx)
    {
        return begin_ListGroups(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ListGroups(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ListGroups(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ListGroups(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ListGroups(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ListGroups(const ::Chat::Callback_GroupServerManager_ListGroupsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ListGroups(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ListGroups(const ::Ice::Context& __ctx, const ::Chat::Callback_GroupServerManager_ListGroupsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ListGroups(&__ctx, __del, __cookie);
    }

    ::Chat::Groups end_ListGroups(const ::Ice::AsyncResultPtr&);
    
private:

    ::Chat::Groups ListGroups(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_ListGroups(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void DeleteGroup(const ::std::string& __p_name)
    {
        DeleteGroup(__p_name, 0);
    }
    void DeleteGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx)
    {
        DeleteGroup(__p_name, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_DeleteGroup(const ::std::string& __p_name, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_DeleteGroup(__p_name, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_DeleteGroup(const ::std::string& __p_name, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_DeleteGroup(__p_name, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_DeleteGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_DeleteGroup(__p_name, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_DeleteGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_DeleteGroup(__p_name, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_DeleteGroup(const ::std::string& __p_name, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& __p_name)
    {
        return begin_DeleteGroup(__p_name, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx)
    {
        return begin_DeleteGroup(__p_name, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& __p_name, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_DeleteGroup(__p_name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_DeleteGroup(__p_name, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& __p_name, const ::Chat::Callback_GroupServerManager_DeleteGroupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_DeleteGroup(__p_name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::Chat::Callback_GroupServerManager_DeleteGroupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_DeleteGroup(__p_name, &__ctx, __del, __cookie);
    }

    void end_DeleteGroup(const ::Ice::AsyncResultPtr&);
    
private:

    void DeleteGroup(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Chat::GroupServerPrx GetGroupServerByName(const ::std::string& __p_name)
    {
        return GetGroupServerByName(__p_name, 0);
    }
    ::Chat::GroupServerPrx GetGroupServerByName(const ::std::string& __p_name, const ::Ice::Context& __ctx)
    {
        return GetGroupServerByName(__p_name, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_GetGroupServerByName(const ::std::string& __p_name, const ::IceInternal::Function<void (const ::Chat::GroupServerPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_GetGroupServerByName(__p_name, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_GetGroupServerByName(const ::std::string& __p_name, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_GetGroupServerByName(__p_name, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_GetGroupServerByName(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Chat::GroupServerPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_GetGroupServerByName(__p_name, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_GetGroupServerByName(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_GetGroupServerByName(__p_name, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_GetGroupServerByName(const ::std::string& __p_name, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Chat::GroupServerPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_GetGroupServerByName(const ::std::string& __p_name)
    {
        return begin_GetGroupServerByName(__p_name, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetGroupServerByName(const ::std::string& __p_name, const ::Ice::Context& __ctx)
    {
        return begin_GetGroupServerByName(__p_name, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetGroupServerByName(const ::std::string& __p_name, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetGroupServerByName(__p_name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetGroupServerByName(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetGroupServerByName(__p_name, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetGroupServerByName(const ::std::string& __p_name, const ::Chat::Callback_GroupServerManager_GetGroupServerByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetGroupServerByName(__p_name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetGroupServerByName(const ::std::string& __p_name, const ::Ice::Context& __ctx, const ::Chat::Callback_GroupServerManager_GetGroupServerByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetGroupServerByName(__p_name, &__ctx, __del, __cookie);
    }

    ::Chat::GroupServerPrx end_GetGroupServerByName(const ::Ice::AsyncResultPtr&);
    
private:

    ::Chat::GroupServerPrx GetGroupServerByName(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_GetGroupServerByName(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_secure(bool __secure) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_twoway() const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_oneway() const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_batchOneway() const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_datagram() const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_batchDatagram() const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_compress(bool __compress) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_timeout(int __timeout) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<GroupServerManager> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<GroupServerManager*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class User : virtual public ::IceProxy::Ice::Object
{
public:

    ::std::string GetName()
    {
        return GetName(0);
    }
    ::std::string GetName(const ::Ice::Context& __ctx)
    {
        return GetName(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_GetName(const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_GetName(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_GetName(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_GetName(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_GetName(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_GetName(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_GetName(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_GetName(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_GetName(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_GetName()
    {
        return begin_GetName(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetName(const ::Ice::Context& __ctx)
    {
        return begin_GetName(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetName(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetName(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetName(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetName(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetName(const ::Chat::Callback_User_GetNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetName(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetName(const ::Ice::Context& __ctx, const ::Chat::Callback_User_GetNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetName(&__ctx, __del, __cookie);
    }

    ::std::string end_GetName(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string GetName(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_GetName(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void ReceiveText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Chat::GroupServerPrx& __p_gServer)
    {
        ReceiveText(__p_msg, __p_sender, __p_gServer, 0);
    }
    void ReceiveText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Chat::GroupServerPrx& __p_gServer, const ::Ice::Context& __ctx)
    {
        ReceiveText(__p_msg, __p_sender, __p_gServer, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_ReceiveText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Chat::GroupServerPrx& __p_gServer, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_ReceiveText(__p_msg, __p_sender, __p_gServer, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_ReceiveText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Chat::GroupServerPrx& __p_gServer, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ReceiveText(__p_msg, __p_sender, __p_gServer, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_ReceiveText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Chat::GroupServerPrx& __p_gServer, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_ReceiveText(__p_msg, __p_sender, __p_gServer, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_ReceiveText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Chat::GroupServerPrx& __p_gServer, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ReceiveText(__p_msg, __p_sender, __p_gServer, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_ReceiveText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Chat::GroupServerPrx& __p_gServer)
    {
        return begin_ReceiveText(__p_msg, __p_sender, __p_gServer, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ReceiveText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Chat::GroupServerPrx& __p_gServer, const ::Ice::Context& __ctx)
    {
        return begin_ReceiveText(__p_msg, __p_sender, __p_gServer, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ReceiveText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Chat::GroupServerPrx& __p_gServer, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ReceiveText(__p_msg, __p_sender, __p_gServer, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ReceiveText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Chat::GroupServerPrx& __p_gServer, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ReceiveText(__p_msg, __p_sender, __p_gServer, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ReceiveText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Chat::GroupServerPrx& __p_gServer, const ::Chat::Callback_User_ReceiveTextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ReceiveText(__p_msg, __p_sender, __p_gServer, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ReceiveText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Chat::GroupServerPrx& __p_gServer, const ::Ice::Context& __ctx, const ::Chat::Callback_User_ReceiveTextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ReceiveText(__p_msg, __p_sender, __p_gServer, &__ctx, __del, __cookie);
    }

    void end_ReceiveText(const ::Ice::AsyncResultPtr&);
    
private:

    void ReceiveText(const ::std::string&, const ::Chat::UserPrx&, const ::Chat::GroupServerPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_ReceiveText(const ::std::string&, const ::Chat::UserPrx&, const ::Chat::GroupServerPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void ReceivePrivateText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender)
    {
        ReceivePrivateText(__p_msg, __p_sender, 0);
    }
    void ReceivePrivateText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Ice::Context& __ctx)
    {
        ReceivePrivateText(__p_msg, __p_sender, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_ReceivePrivateText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_ReceivePrivateText(__p_msg, __p_sender, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_ReceivePrivateText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ReceivePrivateText(__p_msg, __p_sender, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_ReceivePrivateText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_ReceivePrivateText(__p_msg, __p_sender, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_ReceivePrivateText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ReceivePrivateText(__p_msg, __p_sender, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_ReceivePrivateText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender)
    {
        return begin_ReceivePrivateText(__p_msg, __p_sender, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ReceivePrivateText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Ice::Context& __ctx)
    {
        return begin_ReceivePrivateText(__p_msg, __p_sender, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ReceivePrivateText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ReceivePrivateText(__p_msg, __p_sender, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ReceivePrivateText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ReceivePrivateText(__p_msg, __p_sender, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ReceivePrivateText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Chat::Callback_User_ReceivePrivateTextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ReceivePrivateText(__p_msg, __p_sender, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ReceivePrivateText(const ::std::string& __p_msg, const ::Chat::UserPrx& __p_sender, const ::Ice::Context& __ctx, const ::Chat::Callback_User_ReceivePrivateTextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ReceivePrivateText(__p_msg, __p_sender, &__ctx, __del, __cookie);
    }

    void end_ReceivePrivateText(const ::Ice::AsyncResultPtr&);
    
private:

    void ReceivePrivateText(const ::std::string&, const ::Chat::UserPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_ReceivePrivateText(const ::std::string&, const ::Chat::UserPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<User> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_secure(bool __secure) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_twoway() const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_oneway() const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_batchOneway() const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_datagram() const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_batchDatagram() const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_compress(bool __compress) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_timeout(int __timeout) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

namespace Chat
{

class ChatServer : virtual public ::Ice::Object
{
public:

    typedef ChatServerPrx ProxyType;
    typedef ChatServerPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void LogIn(const ::Chat::UserPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___LogIn(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Chat::UserPrx GetUserByName(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___GetUserByName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Chat::Groups GroupList(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___GroupList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Chat::GroupServerPrx GetGroupServerByName(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___GetGroupServerByName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void CreateGroup(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___CreateGroup(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void DeleteGroup(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___DeleteGroup(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void RegisterServer(const ::Chat::GroupServerManagerPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___RegisterServer(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void UnregisterServer(const ::Chat::GroupServerManagerPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___UnregisterServer(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
};

inline bool operator==(const ChatServer& l, const ChatServer& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ChatServer& l, const ChatServer& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class GroupServer : virtual public ::Ice::Object
{
public:

    typedef GroupServerPrx ProxyType;
    typedef GroupServerPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::std::string Name(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___Name(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void Join(const ::Chat::UserPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___Join(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void Leave(const ::Chat::UserPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___Leave(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void SendMessage(const ::std::string&, const ::Chat::UserPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___SendMessage(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Chat::Users UserList(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___UserList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
};

inline bool operator==(const GroupServer& l, const GroupServer& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const GroupServer& l, const GroupServer& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class GroupServerManager : virtual public ::Ice::Object
{
public:

    typedef GroupServerManagerPrx ProxyType;
    typedef GroupServerManagerPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::Chat::GroupServerPrx CreateGroup(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___CreateGroup(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Chat::Groups ListGroups(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___ListGroups(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void DeleteGroup(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___DeleteGroup(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Chat::GroupServerPrx GetGroupServerByName(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___GetGroupServerByName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
};

inline bool operator==(const GroupServerManager& l, const GroupServerManager& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const GroupServerManager& l, const GroupServerManager& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class User : virtual public ::Ice::Object
{
public:

    typedef UserPrx ProxyType;
    typedef UserPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::std::string GetName(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___GetName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void ReceiveText(const ::std::string&, const ::Chat::UserPrx&, const ::Chat::GroupServerPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___ReceiveText(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void ReceivePrivateText(const ::std::string&, const ::Chat::UserPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___ReceivePrivateText(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
};

inline bool operator==(const User& l, const User& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const User& l, const User& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace Chat
{

template<class T>
class CallbackNC_ChatServer_LogIn : public Callback_ChatServer_LogIn_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatServer_LogIn(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_LogIn(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_ChatServer_LogInPtr
newCallback_ChatServer_LogIn(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_LogIn<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_LogInPtr
newCallback_ChatServer_LogIn(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_LogIn<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatServer_LogInPtr
newCallback_ChatServer_LogIn(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_LogIn<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_LogInPtr
newCallback_ChatServer_LogIn(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_LogIn<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_LogIn : public Callback_ChatServer_LogIn_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatServer_LogIn(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_LogIn(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_ChatServer_LogInPtr
newCallback_ChatServer_LogIn(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_LogIn<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_LogInPtr
newCallback_ChatServer_LogIn(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_LogIn<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_LogInPtr
newCallback_ChatServer_LogIn(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_LogIn<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_LogInPtr
newCallback_ChatServer_LogIn(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_LogIn<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_GetUserByName : public Callback_ChatServer_GetUserByName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Chat::UserPrx&);

    CallbackNC_ChatServer_GetUserByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        ::Chat::UserPrx __ret;
        try
        {
            __ret = __proxy->end_GetUserByName(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_ChatServer_GetUserByNamePtr
newCallback_ChatServer_GetUserByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::UserPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_GetUserByName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_GetUserByNamePtr
newCallback_ChatServer_GetUserByName(T* instance, void (T::*cb)(const ::Chat::UserPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_GetUserByName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_GetUserByName : public Callback_ChatServer_GetUserByName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Chat::UserPrx&, const CT&);

    Callback_ChatServer_GetUserByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        ::Chat::UserPrx __ret;
        try
        {
            __ret = __proxy->end_GetUserByName(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_ChatServer_GetUserByNamePtr
newCallback_ChatServer_GetUserByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::UserPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_GetUserByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_GetUserByNamePtr
newCallback_ChatServer_GetUserByName(T* instance, void (T::*cb)(const ::Chat::UserPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_GetUserByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_GroupList : public Callback_ChatServer_GroupList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Chat::Groups&);

    CallbackNC_ChatServer_GroupList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        ::Chat::Groups __ret;
        try
        {
            __ret = __proxy->end_GroupList(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_ChatServer_GroupListPtr
newCallback_ChatServer_GroupList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::Groups&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_GroupList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_GroupListPtr
newCallback_ChatServer_GroupList(T* instance, void (T::*cb)(const ::Chat::Groups&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_GroupList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_GroupList : public Callback_ChatServer_GroupList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Chat::Groups&, const CT&);

    Callback_ChatServer_GroupList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        ::Chat::Groups __ret;
        try
        {
            __ret = __proxy->end_GroupList(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_ChatServer_GroupListPtr
newCallback_ChatServer_GroupList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::Groups&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_GroupList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_GroupListPtr
newCallback_ChatServer_GroupList(T* instance, void (T::*cb)(const ::Chat::Groups&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_GroupList<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_GetGroupServerByName : public Callback_ChatServer_GetGroupServerByName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Chat::GroupServerPrx&);

    CallbackNC_ChatServer_GetGroupServerByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        ::Chat::GroupServerPrx __ret;
        try
        {
            __ret = __proxy->end_GetGroupServerByName(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_ChatServer_GetGroupServerByNamePtr
newCallback_ChatServer_GetGroupServerByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::GroupServerPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_GetGroupServerByName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_GetGroupServerByNamePtr
newCallback_ChatServer_GetGroupServerByName(T* instance, void (T::*cb)(const ::Chat::GroupServerPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_GetGroupServerByName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_GetGroupServerByName : public Callback_ChatServer_GetGroupServerByName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Chat::GroupServerPrx&, const CT&);

    Callback_ChatServer_GetGroupServerByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        ::Chat::GroupServerPrx __ret;
        try
        {
            __ret = __proxy->end_GetGroupServerByName(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_ChatServer_GetGroupServerByNamePtr
newCallback_ChatServer_GetGroupServerByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::GroupServerPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_GetGroupServerByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_GetGroupServerByNamePtr
newCallback_ChatServer_GetGroupServerByName(T* instance, void (T::*cb)(const ::Chat::GroupServerPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_GetGroupServerByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_CreateGroup : public Callback_ChatServer_CreateGroup_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatServer_CreateGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_CreateGroup(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_ChatServer_CreateGroupPtr
newCallback_ChatServer_CreateGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_CreateGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_CreateGroupPtr
newCallback_ChatServer_CreateGroup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_CreateGroup<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatServer_CreateGroupPtr
newCallback_ChatServer_CreateGroup(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_CreateGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_CreateGroupPtr
newCallback_ChatServer_CreateGroup(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_CreateGroup<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_CreateGroup : public Callback_ChatServer_CreateGroup_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatServer_CreateGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_CreateGroup(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_ChatServer_CreateGroupPtr
newCallback_ChatServer_CreateGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_CreateGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_CreateGroupPtr
newCallback_ChatServer_CreateGroup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_CreateGroup<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_CreateGroupPtr
newCallback_ChatServer_CreateGroup(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_CreateGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_CreateGroupPtr
newCallback_ChatServer_CreateGroup(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_CreateGroup<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_DeleteGroup : public Callback_ChatServer_DeleteGroup_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatServer_DeleteGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_DeleteGroup(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_ChatServer_DeleteGroupPtr
newCallback_ChatServer_DeleteGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_DeleteGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_DeleteGroupPtr
newCallback_ChatServer_DeleteGroup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_DeleteGroup<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatServer_DeleteGroupPtr
newCallback_ChatServer_DeleteGroup(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_DeleteGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_DeleteGroupPtr
newCallback_ChatServer_DeleteGroup(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_DeleteGroup<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_DeleteGroup : public Callback_ChatServer_DeleteGroup_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatServer_DeleteGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_DeleteGroup(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_ChatServer_DeleteGroupPtr
newCallback_ChatServer_DeleteGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_DeleteGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_DeleteGroupPtr
newCallback_ChatServer_DeleteGroup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_DeleteGroup<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_DeleteGroupPtr
newCallback_ChatServer_DeleteGroup(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_DeleteGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_DeleteGroupPtr
newCallback_ChatServer_DeleteGroup(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_DeleteGroup<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_RegisterServer : public Callback_ChatServer_RegisterServer_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatServer_RegisterServer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_RegisterServer(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_ChatServer_RegisterServerPtr
newCallback_ChatServer_RegisterServer(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_RegisterServer<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_RegisterServerPtr
newCallback_ChatServer_RegisterServer(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_RegisterServer<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatServer_RegisterServerPtr
newCallback_ChatServer_RegisterServer(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_RegisterServer<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_RegisterServerPtr
newCallback_ChatServer_RegisterServer(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_RegisterServer<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_RegisterServer : public Callback_ChatServer_RegisterServer_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatServer_RegisterServer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_RegisterServer(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_ChatServer_RegisterServerPtr
newCallback_ChatServer_RegisterServer(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_RegisterServer<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_RegisterServerPtr
newCallback_ChatServer_RegisterServer(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_RegisterServer<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_RegisterServerPtr
newCallback_ChatServer_RegisterServer(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_RegisterServer<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_RegisterServerPtr
newCallback_ChatServer_RegisterServer(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_RegisterServer<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_UnregisterServer : public Callback_ChatServer_UnregisterServer_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatServer_UnregisterServer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_UnregisterServer(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_ChatServer_UnregisterServerPtr
newCallback_ChatServer_UnregisterServer(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_UnregisterServer<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_UnregisterServerPtr
newCallback_ChatServer_UnregisterServer(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_UnregisterServer<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatServer_UnregisterServerPtr
newCallback_ChatServer_UnregisterServer(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_UnregisterServer<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_UnregisterServerPtr
newCallback_ChatServer_UnregisterServer(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_UnregisterServer<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_UnregisterServer : public Callback_ChatServer_UnregisterServer_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatServer_UnregisterServer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_UnregisterServer(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_ChatServer_UnregisterServerPtr
newCallback_ChatServer_UnregisterServer(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_UnregisterServer<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_UnregisterServerPtr
newCallback_ChatServer_UnregisterServer(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_UnregisterServer<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_UnregisterServerPtr
newCallback_ChatServer_UnregisterServer(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_UnregisterServer<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_UnregisterServerPtr
newCallback_ChatServer_UnregisterServer(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_UnregisterServer<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GroupServer_Name : public Callback_GroupServer_Name_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_GroupServer_Name(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerPrx __proxy = ::Chat::GroupServerPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_Name(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_GroupServer_NamePtr
newCallback_GroupServer_Name(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_Name<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServer_NamePtr
newCallback_GroupServer_Name(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_Name<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_GroupServer_Name : public Callback_GroupServer_Name_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_GroupServer_Name(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerPrx __proxy = ::Chat::GroupServerPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_Name(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_GroupServer_NamePtr
newCallback_GroupServer_Name(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_Name<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_NamePtr
newCallback_GroupServer_Name(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_Name<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_GroupServer_Join : public Callback_GroupServer_Join_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GroupServer_Join(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerPrx __proxy = ::Chat::GroupServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_Join(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_GroupServer_JoinPtr
newCallback_GroupServer_Join(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_Join<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServer_JoinPtr
newCallback_GroupServer_Join(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_Join<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GroupServer_JoinPtr
newCallback_GroupServer_Join(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_Join<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServer_JoinPtr
newCallback_GroupServer_Join(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_Join<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GroupServer_Join : public Callback_GroupServer_Join_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GroupServer_Join(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerPrx __proxy = ::Chat::GroupServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_Join(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_GroupServer_JoinPtr
newCallback_GroupServer_Join(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_Join<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_JoinPtr
newCallback_GroupServer_Join(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_Join<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_JoinPtr
newCallback_GroupServer_Join(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_Join<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_JoinPtr
newCallback_GroupServer_Join(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_Join<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GroupServer_Leave : public Callback_GroupServer_Leave_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GroupServer_Leave(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerPrx __proxy = ::Chat::GroupServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_Leave(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_GroupServer_LeavePtr
newCallback_GroupServer_Leave(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_Leave<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServer_LeavePtr
newCallback_GroupServer_Leave(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_Leave<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GroupServer_LeavePtr
newCallback_GroupServer_Leave(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_Leave<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServer_LeavePtr
newCallback_GroupServer_Leave(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_Leave<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GroupServer_Leave : public Callback_GroupServer_Leave_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GroupServer_Leave(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerPrx __proxy = ::Chat::GroupServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_Leave(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_GroupServer_LeavePtr
newCallback_GroupServer_Leave(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_Leave<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_LeavePtr
newCallback_GroupServer_Leave(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_Leave<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_LeavePtr
newCallback_GroupServer_Leave(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_Leave<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_LeavePtr
newCallback_GroupServer_Leave(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_Leave<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GroupServer_SendMessage : public Callback_GroupServer_SendMessage_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GroupServer_SendMessage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerPrx __proxy = ::Chat::GroupServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_SendMessage(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_GroupServer_SendMessagePtr
newCallback_GroupServer_SendMessage(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_SendMessage<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServer_SendMessagePtr
newCallback_GroupServer_SendMessage(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_SendMessage<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GroupServer_SendMessagePtr
newCallback_GroupServer_SendMessage(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_SendMessage<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServer_SendMessagePtr
newCallback_GroupServer_SendMessage(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_SendMessage<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GroupServer_SendMessage : public Callback_GroupServer_SendMessage_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GroupServer_SendMessage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerPrx __proxy = ::Chat::GroupServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_SendMessage(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_GroupServer_SendMessagePtr
newCallback_GroupServer_SendMessage(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_SendMessage<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_SendMessagePtr
newCallback_GroupServer_SendMessage(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_SendMessage<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_SendMessagePtr
newCallback_GroupServer_SendMessage(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_SendMessage<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_SendMessagePtr
newCallback_GroupServer_SendMessage(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_SendMessage<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GroupServer_UserList : public Callback_GroupServer_UserList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Chat::Users&);

    CallbackNC_GroupServer_UserList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerPrx __proxy = ::Chat::GroupServerPrx::uncheckedCast(__result->getProxy());
        ::Chat::Users __ret;
        try
        {
            __ret = __proxy->end_UserList(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_GroupServer_UserListPtr
newCallback_GroupServer_UserList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::Users&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_UserList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServer_UserListPtr
newCallback_GroupServer_UserList(T* instance, void (T::*cb)(const ::Chat::Users&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_UserList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_GroupServer_UserList : public Callback_GroupServer_UserList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Chat::Users&, const CT&);

    Callback_GroupServer_UserList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerPrx __proxy = ::Chat::GroupServerPrx::uncheckedCast(__result->getProxy());
        ::Chat::Users __ret;
        try
        {
            __ret = __proxy->end_UserList(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_GroupServer_UserListPtr
newCallback_GroupServer_UserList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::Users&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_UserList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_UserListPtr
newCallback_GroupServer_UserList(T* instance, void (T::*cb)(const ::Chat::Users&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_UserList<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_GroupServerManager_CreateGroup : public Callback_GroupServerManager_CreateGroup_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Chat::GroupServerPrx&);

    CallbackNC_GroupServerManager_CreateGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerManagerPrx __proxy = ::Chat::GroupServerManagerPrx::uncheckedCast(__result->getProxy());
        ::Chat::GroupServerPrx __ret;
        try
        {
            __ret = __proxy->end_CreateGroup(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_GroupServerManager_CreateGroupPtr
newCallback_GroupServerManager_CreateGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::GroupServerPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_CreateGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServerManager_CreateGroupPtr
newCallback_GroupServerManager_CreateGroup(T* instance, void (T::*cb)(const ::Chat::GroupServerPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_CreateGroup<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_GroupServerManager_CreateGroup : public Callback_GroupServerManager_CreateGroup_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Chat::GroupServerPrx&, const CT&);

    Callback_GroupServerManager_CreateGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerManagerPrx __proxy = ::Chat::GroupServerManagerPrx::uncheckedCast(__result->getProxy());
        ::Chat::GroupServerPrx __ret;
        try
        {
            __ret = __proxy->end_CreateGroup(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_GroupServerManager_CreateGroupPtr
newCallback_GroupServerManager_CreateGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::GroupServerPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_CreateGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServerManager_CreateGroupPtr
newCallback_GroupServerManager_CreateGroup(T* instance, void (T::*cb)(const ::Chat::GroupServerPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_CreateGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_GroupServerManager_ListGroups : public Callback_GroupServerManager_ListGroups_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Chat::Groups&);

    CallbackNC_GroupServerManager_ListGroups(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerManagerPrx __proxy = ::Chat::GroupServerManagerPrx::uncheckedCast(__result->getProxy());
        ::Chat::Groups __ret;
        try
        {
            __ret = __proxy->end_ListGroups(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_GroupServerManager_ListGroupsPtr
newCallback_GroupServerManager_ListGroups(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::Groups&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_ListGroups<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServerManager_ListGroupsPtr
newCallback_GroupServerManager_ListGroups(T* instance, void (T::*cb)(const ::Chat::Groups&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_ListGroups<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_GroupServerManager_ListGroups : public Callback_GroupServerManager_ListGroups_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Chat::Groups&, const CT&);

    Callback_GroupServerManager_ListGroups(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerManagerPrx __proxy = ::Chat::GroupServerManagerPrx::uncheckedCast(__result->getProxy());
        ::Chat::Groups __ret;
        try
        {
            __ret = __proxy->end_ListGroups(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_GroupServerManager_ListGroupsPtr
newCallback_GroupServerManager_ListGroups(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::Groups&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_ListGroups<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServerManager_ListGroupsPtr
newCallback_GroupServerManager_ListGroups(T* instance, void (T::*cb)(const ::Chat::Groups&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_ListGroups<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_GroupServerManager_DeleteGroup : public Callback_GroupServerManager_DeleteGroup_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GroupServerManager_DeleteGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerManagerPrx __proxy = ::Chat::GroupServerManagerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_DeleteGroup(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_GroupServerManager_DeleteGroupPtr
newCallback_GroupServerManager_DeleteGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_DeleteGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServerManager_DeleteGroupPtr
newCallback_GroupServerManager_DeleteGroup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_DeleteGroup<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GroupServerManager_DeleteGroupPtr
newCallback_GroupServerManager_DeleteGroup(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_DeleteGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServerManager_DeleteGroupPtr
newCallback_GroupServerManager_DeleteGroup(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_DeleteGroup<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GroupServerManager_DeleteGroup : public Callback_GroupServerManager_DeleteGroup_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GroupServerManager_DeleteGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerManagerPrx __proxy = ::Chat::GroupServerManagerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_DeleteGroup(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_GroupServerManager_DeleteGroupPtr
newCallback_GroupServerManager_DeleteGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_DeleteGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServerManager_DeleteGroupPtr
newCallback_GroupServerManager_DeleteGroup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_DeleteGroup<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServerManager_DeleteGroupPtr
newCallback_GroupServerManager_DeleteGroup(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_DeleteGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServerManager_DeleteGroupPtr
newCallback_GroupServerManager_DeleteGroup(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_DeleteGroup<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GroupServerManager_GetGroupServerByName : public Callback_GroupServerManager_GetGroupServerByName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Chat::GroupServerPrx&);

    CallbackNC_GroupServerManager_GetGroupServerByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerManagerPrx __proxy = ::Chat::GroupServerManagerPrx::uncheckedCast(__result->getProxy());
        ::Chat::GroupServerPrx __ret;
        try
        {
            __ret = __proxy->end_GetGroupServerByName(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_GroupServerManager_GetGroupServerByNamePtr
newCallback_GroupServerManager_GetGroupServerByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::GroupServerPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_GetGroupServerByName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServerManager_GetGroupServerByNamePtr
newCallback_GroupServerManager_GetGroupServerByName(T* instance, void (T::*cb)(const ::Chat::GroupServerPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_GetGroupServerByName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_GroupServerManager_GetGroupServerByName : public Callback_GroupServerManager_GetGroupServerByName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Chat::GroupServerPrx&, const CT&);

    Callback_GroupServerManager_GetGroupServerByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::GroupServerManagerPrx __proxy = ::Chat::GroupServerManagerPrx::uncheckedCast(__result->getProxy());
        ::Chat::GroupServerPrx __ret;
        try
        {
            __ret = __proxy->end_GetGroupServerByName(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_GroupServerManager_GetGroupServerByNamePtr
newCallback_GroupServerManager_GetGroupServerByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::GroupServerPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_GetGroupServerByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServerManager_GetGroupServerByNamePtr
newCallback_GroupServerManager_GetGroupServerByName(T* instance, void (T::*cb)(const ::Chat::GroupServerPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_GetGroupServerByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_User_GetName : public Callback_User_GetName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_User_GetName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::UserPrx __proxy = ::Chat::UserPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_GetName(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_User_GetNamePtr
newCallback_User_GetName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_GetName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_GetNamePtr
newCallback_User_GetName(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_GetName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_User_GetName : public Callback_User_GetName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_User_GetName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::UserPrx __proxy = ::Chat::UserPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_GetName(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_User_GetNamePtr
newCallback_User_GetName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_GetName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_GetNamePtr
newCallback_User_GetName(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_GetName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_User_ReceiveText : public Callback_User_ReceiveText_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_User_ReceiveText(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_User_ReceiveTextPtr
newCallback_User_ReceiveText(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_ReceiveText<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_ReceiveTextPtr
newCallback_User_ReceiveText(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_ReceiveText<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_User_ReceiveTextPtr
newCallback_User_ReceiveText(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_ReceiveText<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_ReceiveTextPtr
newCallback_User_ReceiveText(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_ReceiveText<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_User_ReceiveText : public Callback_User_ReceiveText_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_User_ReceiveText(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_User_ReceiveTextPtr
newCallback_User_ReceiveText(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_ReceiveText<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_ReceiveTextPtr
newCallback_User_ReceiveText(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_ReceiveText<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_User_ReceiveTextPtr
newCallback_User_ReceiveText(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_ReceiveText<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_ReceiveTextPtr
newCallback_User_ReceiveText(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_ReceiveText<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_User_ReceivePrivateText : public Callback_User_ReceivePrivateText_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_User_ReceivePrivateText(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_User_ReceivePrivateTextPtr
newCallback_User_ReceivePrivateText(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_ReceivePrivateText<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_ReceivePrivateTextPtr
newCallback_User_ReceivePrivateText(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_ReceivePrivateText<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_User_ReceivePrivateTextPtr
newCallback_User_ReceivePrivateText(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_ReceivePrivateText<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_ReceivePrivateTextPtr
newCallback_User_ReceivePrivateText(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_ReceivePrivateText<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_User_ReceivePrivateText : public Callback_User_ReceivePrivateText_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_User_ReceivePrivateText(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_User_ReceivePrivateTextPtr
newCallback_User_ReceivePrivateText(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_ReceivePrivateText<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_ReceivePrivateTextPtr
newCallback_User_ReceivePrivateText(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_ReceivePrivateText<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_User_ReceivePrivateTextPtr
newCallback_User_ReceivePrivateText(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_ReceivePrivateText<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_ReceivePrivateTextPtr
newCallback_User_ReceivePrivateText(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_ReceivePrivateText<T, CT>(instance, 0, excb, sentcb);
}

}

#include <IceUtil/PopDisableWarnings.h>
#endif
